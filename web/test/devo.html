<!DOCTYPE html>
<!--

color spec #3817d5 (W)


-->
<html>
  <head>
    <meta charset="utf-8" />
    <title>New webpage</title>
    <style>
      html,
      body {
        width: 100%;
        height: 100%;
        padding: 0;
        margin: 0;
      }
      #canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      #overlay {
        position: absolute;
        top: 0;
        left: 0;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"> </canvas>
    <div id="overlay">
      <h1>Devoid</h1>
    </div>
  </body>
  <script type>
    const presetLib = {
      missile: `    33  3
    WWWWW  AWW
    W   W  B W
    W   WWWWWW
    WWWWWW 1111
    WBAWW`,
    };

    let canvasW, canvasH;
    function windowResize() {
      const canvas = document.getElementById("canvas");
      canvas.width = document.body.clientWidth; //document.width is obsolete
      canvas.height = document.body.clientHeight; //document.height is obsolete
      canvasW = canvas.width;
      canvasH = canvas.height;
    }
    windowResize();
    window.addEventListener("resize", windowResize);
    const canvasElement = document.getElementById("canvas");
    const ctx = canvasElement.getContext("2d");

    const cam = {
      // Camera variables
      ht: 0.001, // ht = height, the number of pixels high the camera is from the ground
      gotoHt: 0.033, // Used for the smooth effect when zooming with the mouse scroll
      x: 10,
      y: 10,
      dragForceX: 0, // Used for the smooth effect when panning around the map
      dragForceY: 0, // ^
      minHt: 0.005, // Inwards zoom limit
      maxHt: 1, // Outwards zoom limit
      hw: canvasW / 2, // hw = half width of canvas
      hh: canvasH / 2, // hh = half height of canvas
    };
    let sprites = {};
    ["player", "player_thrust", ..."01234567WABD".split("")].forEach((char) => {
      let img = new Image();
      img.src = `${char}.png`;
      sprites[char] = img;
    });

    const X = (cor) => {
      // Calculate on-screen position based on camera variables (x, y, height)
      // Took me many hours to figure this out myself (I didn't look up any formulas), I refined these functions in Python many times and converted it to JS.
      return (cor - cam.x) / cam.ht + cam.hw;
    };
    const Y = (cor) => {
      return (cor - cam.y) / cam.ht + cam.hh;
    };
    const S = (size) => {
      return size / cam.ht;
    };
    const RevX = (pos) => {
      return (pos - cam.hw) * cam.ht + cam.x;
    };
    const RevY = (pos) => {
      return (pos - cam.hh) * cam.ht + cam.y;
    };
    const RevS = (size) => {
      return size * cam.ht;
    };
    const cameraUpdate = (followMe) => {
      if (cam.ht < cam.gotoHt / 1.01) {
        cam.ht += (cam.gotoHt - cam.ht) * 0.4;
      } else if (cam.ht > cam.gotoHt * 1.01) {
        cam.ht -= (cam.ht - cam.gotoHt) * 0.4;
      } else {
        cam.ht = cam.gotoHt;
      }

      cam.gotoHt = Math.min(Math.max(cam.gotoHt, cam.minHt), cam.maxHt);

      // camera follow player
      cam.x += (followMe.x - cam.x) * 0.83;
      cam.y += (followMe.y - cam.y) * 0.83;
    };

    class PlayerCraft {
      constructor(color, x, y) {
        this.color = color;
        this.x = x;
        this.y = y;
        this.speed = 0;
        this.maxSpeed = 0.4;
        this.rot = 0;
        this.mass = 2;
        this.thrusterOn = false;
      }

      update() {
        this.x += Math.cos(this.rot) * this.speed;
        this.y += Math.sin(this.rot) * this.speed;
      }

      mouseControls(mouse, isMousePressed) {
        let chX = RevX(mouse.x) - this.x;
        let chY = RevY(mouse.y) - this.y;
        let dist = Math.sqrt(chX * chX + chY * chY);
        let theta = Math.atan2(chY, chX);
        if (this.rot > theta + Math.PI) {
          this.rot -= Math.PI * 2;
        } else if (this.rot < theta - Math.PI) {
          this.rot += Math.PI * 2;
        }
        this.rot += (theta - this.rot) * 0.1;

        this.thrusterOn = isMousePressed;
        if (isMousePressed) {
          this.speed += (this.maxSpeed - this.speed) * 0.04;
        } else {
          this.speed += (0 - this.speed) * 0.08;
        }
      }

      draw() {
        const img = sprites[this.thrusterOn ? "player_thrust" : "player"];
        const s = S(1);
        ctx.translate(X(this.x), Y(this.y));
        ctx.rotate(this.rot + Math.PI / 2);
        ctx.drawImage(img, -s / 2, -s / 2, s, s);
        ctx.setTransform(1, 0, 0, 1, 0, 0);
      }
    }

    const factions = [];
    class Faction {
      constructor(id, name, logoUrl, color, isSpecial) {
        factions.push(this);
        this.id = id;
        this.name = name;
        this.logoUrl = logoUrl;
        this.color = color;
        this.isSpecial = isSpecial;
      }
    }
    new Faction("none", "No faction", "#0000ff");

    class Craft {
      constructor(preset, x, y) {
        this.preset = preset;
        this.name = parseInt(Math.random().toString().slice(10)).toString(36);
        this.factionId = "none";
        this.x = x;
        this.y = y;
        this.w = 0;
        this.h = 0;
        this.cellsByHash = {};
        this.cells = [];
        this.inertiaX = 0;
        this.inertiaY = 0;
        this.mass = 1000;
        if (preset) this.addCellsFromPreset(preset);
      }

      addCell(type, lx, ly) {
        this.w = Math.max(this.w, lx + 1);
        this.h = Math.max(this.h, ly + 1);
        this.mass++;
        console.log(lx);
        const c = new Cell(this, type, lx, ly);
        this.cells.push(c);

        // neighbors logic
        const cbh = this.cellsByHash;
        cbh[`${lx}|${ly}`] = c;
        const neighborhoodDefinition = [
          { x: -1, y: -1 },
          { x: 0, y: -1 },
          { x: 1, y: -1 },
          { x: -1, y: 0 },
        ];
        for (let offset of neighborhoodDefinition) {
          let neighborCell = cbh[`${lx + offset.x}|${ly + offset.y}`];
          if (neighborCell) {
            neighborCell.neighbors.push(c);
            c.neighbors.push(neighborCell);
          }
        }
      }

      addCellsFromPreset(preset) {
        const craftCode = presetLib[preset];
        if (!craftCode) return;
        let y = -1;
        for (let line of craftCode.split("\n")) {
          y++;
          let x = -1;
          for (let char of line) {
            x++;
            if (char === " ") continue;
            this.addCell(char, x, y);
          }
        }
        for (let cell of this.cells) {
          cell.init();
        }
      }

      update() {
        for (let cell of this.cells) {
          cell.beforeUpdate(this);
        }
        for (let cell of this.cells) {
          cell.update(this);
        }

        this.x += this.inertiaX / this.mass;
        this.y += this.inertiaY / this.mass;
      }

      draw() {
        this.cells.forEach((cell) => cell.draw());

        ctx.strokeStyle = "blue";
        ctx.strokeRect(
          X(this.x - 0.4),
          Y(this.y - 0.4),
          S(this.w + 0.8),
          S(this.h + 0.8)
        );
      }
    }

    class Cell {
      constructor(parentCraft, type, lx, ly) {
        // lx = local x in relation to craft
        this.parentCraft = parentCraft; // parent craft
        this.type = type;
        this.lx = lx;
        this.ly = ly;
        this.neighbors = [];
        this.actionPotential = 0;
        this.age = 0;
      }

      init() {
        const craft = this.parentCraft;
        switch (this.type) {
          case "4": {
            craft.inertiaX += 1;
            break;
          }
          case "5": {
            craft.inertiaY += -1;
            break;
          }
          case "6": {
            craft.inertiaX += -1;
            break;
          }
          case "7": {
            craft.inertiaY += 1;
            break;
          }
          default: {
          }
        }
      }

      deInit() {
        const craft = this.parentCraft;
        switch (this.type) {
          case "4": {
            craft.inertiaX -= 1;
            break;
          }
          case "5": {
            craft.inertiaY -= -1;
            break;
          }
          case "6": {
            craft.inertiaX -= -1;
            break;
          }
          case "7": {
            craft.inertiaY -= 1;
            break;
          }
          default: {
          }
        }
      }

      changeType(changeToType) {
        this.deInit();
        this.type = changeToType;
        this.init();
      }

      beforeUpdate() {
        // Give action potentials
        if (this.type === "A") {
          for (let neighbor of this.neighbors) {
            neighbor.actionPotential++;
          }

          //this.changeType("W");
        }
      }

      update() {
        const craft = this.parentCraft;
        switch (this.type) {
          case "A": {
            this.changeType("B");
            break;
          }
          case "B": {
            this.changeType("W");
            break;
          }
          case "W": {
            if (this.actionPotential === 1) {
              // 1, 2, 3, 4 (or 1, 3... or 1 only?)
              this.changeType("A");
            }
            break;
          }
          case "D": {
            break;
          }
          default: {
            if (this.actionPotential > 0) {
              this.changeType(((parseInt(this.type) + 4) % 8).toString());
            }
          }
        }
        this.actionPotential = 0; // Reset action potential
      }

      draw() {
        const img = sprites[this.type];
        const craft = this.parentCraft;
        const s = S(1);
        // is (img.loading) continue;
        ctx.drawImage(img, X(craft.x + this.lx), Y(craft.y + this.ly), s, s);
      }
    }

    class Game {
      constructor() {
        this.crafts = [];
        this.me = null;
        this.loaded = false;
      }

      initDemo() {
        const c = new Craft("missile", 10, 10);
        this.crafts.push(c);
        this.me = new PlayerCraft("#ff0000", 10, 10);
        this.loaded = true;
      }

      nextStep() {
        for (let craft of this.crafts) {
          craft.update();
        }
        this.me.mouseControls(mouse, isMousePressed);
        this.me.update();
      }

      draw() {
        cameraUpdate(this.me);
        ctx.clearRect(0, 0, canvasW, canvasH);
        for (let craft of this.crafts) {
          craft.draw();
        }
        this.me.draw();
      }
    }

    function onKeyDown(event) {
      if (event.keyCode === 83) {
        // S
        // game.nextStep();
      }
    }
    window.onkeydown = onKeyDown;

    function getMousePos(canvas, evt) {
      var rect = canvas.getBoundingClientRect();
      return {
        x:
          ((evt.clientX - rect.left) / (rect.right - rect.left)) * canvas.width,
        y:
          ((evt.clientY - rect.top) / (rect.bottom - rect.top)) * canvas.height,
      };
    }
    let isMousePressed = false;
    let mouse = { x: 0, y: 0 };
    window.addEventListener(
      "mousemove",
      (evt) => {
        mouse = getMousePos(canvasElement, evt);
      },
      false
    );
    window.addEventListener("mousedown", (evt) => {
      isMousePressed = true;
    });
    window.addEventListener("mouseup", (evt) => {
      isMousePressed = false;
    });
    window.addEventListener("wheel", (evt) => {
      cam.gotoHt *= 1 + evt.deltaY / 500;
    });

    const game = new Game();
    window.game = game;
    game.initDemo();
    function gameLoop() {
      window.requestAnimationFrame(gameLoop);
      game.draw();
    }

    setInterval(() => {
      if (game.loaded) game.nextStep();
    }, 1000 / 50);
    gameLoop();
  </script>
</html>
